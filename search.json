[{"url":"/smile/2023/01/17/1/","content":"function Fn(){};\nFn.prototype = new Array();\nvar f = new Fn();\nvar a = Object.prototype.toString\nconsole.log(a.call(f)) // '[object Object]'\n"},{"title":"数据结构","url":"/smile/2023/01/17/数据结构/","content":"js 数据结构 包括 null undefined string number boolean symbol bitInt\n<!-- more -->\njavascript是一种动态类型的动态语言，变量的值与任何类型都没有任何关联，可以随意分配和复制\njavascript是一个弱类型的语言，它运行在操作中可以进行适当的隐私类型转换\n# 基本类型 vs 引用类型\n**原始类型** 不可变值 7种 null undefined string number boolean symbol bigint\n**引用类型** object array date function regex正则 Set Map\n> **引用类型和基本类型的区别**\n> 原始类型是按值存在栈内存中（先进后出 自动分配）大小固定 ；引用类型是把指针存在栈内存中，值存在堆内存中（优先级 开发者分配），指针指向的是内存堆中对应的实际值。\n> 基本类型是按照值传递，互不影响；引用类型是按照引用传递（一改都改 互相影响）\n## null\n只有一个值为null，表示空对象，一般给对象作为初始值 或者 大对象回收内存 时使用。没有包装对象。\n## undefined\n只有一个值为undefined，表示未定义，没有任何值。没有包装对象。\n以下情况默认值为undefined:\n1. 变量声明了但是没有给初始值 \n2. 函数没有传参数 \n3. 函数return没有值 \n4. 不存在的对象 \n> **typeof null === \"object\"**\n> 原因 在js最初的实现里面 js的值是有一个表示类型的标签和实际数值表示 \n> 由于null 代表空指针 对于大多数平台来说是 0x00 null的类型标签是0 而 对象类型对应的标签也是0 \n> 因此 typeof null 就是object\n## Boolean\n有两个值 true false\n## Number\n双进度浮点数 超出范围会等于 Number.MAX_SAFE_INTEGER\n### NaN not a number 一种特殊的数值 表示不是数字 \nNaN!==NaN 它不等一自身 用isNaN判断 isNaN(NaN) === true \n> 0.1+0.2 !== 0.3 原因 \n> 实际 0.1+0.2  = 0.30000000000000004\n> 计算机是用二进制存储数据的，0.1 是一个循环数 0.2也是一个循环数。js是采用双精度浮点数，小数点最多能保留52位，会导致精度丢失。 \n> 浮点数存储：符号位（1）+指数位（11）+小数位（52） \n> 符号为 正数为0 负数为1\n> 指数为 是把数字转换为二进制后再转换位科学计数法得到的指数，再通过调整+1023 ,再转换为二进制得到\n> 小数为 是把数字转换为二进制后再转换位科学计数法得到的指数 省略1得到\n> 例如0.1的小数为1001 1001 的无限循环超过52位 要0舍1入 进度丢失\n> 解决办法：判断是否在误差范围内(小于) Number.EPSION\n## BigInt\n表示任意大小的整数 大整数\n`const x = BigInt(Number.MAX_SAFE_INTEGER)`\n## String\n字符串类型\n## Symbol类型\n唯一并且不可变的原始值 用对存储对象的key。目的是：用于创建唯一属性值 保证不会与其它代码中的key产生冲突。\n\n# 类型检测\n## typeof\n基本类型 typeof null = object 除了null是object以外其它的都是对的\n引用类型 全是object 不能判断引用类型\n## instanceof\n用于判断对象的类型 本质是判断对象的原型链上是否存在该类型的原型 \n基本类型 不能判断 但是可以判断 string boolean number的包装类型\n引用类型 可以判断没有修改原型的应用类型\n```js\n2 instanceof Number // false\n\"a\" instanceof String // false\ntrue instanceof Boolean // false\n\n(new Number(1)) instanceof Number // true\n\n[] instanceof Array // true\nfunction(){} instanceof Function //true\n{} instanceof Object // true\n\n\nfunction Fn(){}\nFn.prototype = new Array()\nvar f = new Fn()\nf instanceof Arrary // true\nf instanceof Function // false\n```\n## constructor\n获取构造函数\n基本类型 可以判断除了null undefined的基本类型 和 string number boolean的包装类型\n引用类型 可以判断没有修改原型的应用类型\n```js\n(2).constructor === Number //true\n(new Number(2)).constructor === Number //true\n('str').constructor === String //true\n(true).constructor === Boolean //true\n([]).constructor === Array //true\n(function() {}).constructor === Function //true\n({}).constructor === Object //true\n\nfunction Fn(){};\nFn.prototype = new Array();\nvar f = new Fn();\nf.constructor===Fn  // false\nf.constructor===Array // true\n\nobj.__proto__ === Array.prototype;\n```\n## Object.prototype.toString.call()\n本质：利用Object原型链上的toString方法 遇到null undefined 就返回[object null] [object undefined]，如果不是就先转换为对象，基本类型被转化为它的包装对象 。转换后用取得该对象的 [Symbol.toStringTag]属性 和object拼装 就是得到值。可以手动改[Symbol.toStringTag]属性\n排除手动改Symbol.toStringTag的情况 可以判断全部类型\n```js\nvar a = Object.prototype.toString\na.call(1) //'[object Number]'\na.call(new Number(1))//'[object Number]'\na.call('a') //'[object String]'\na.call('boolean') //'[object String]'\na.call(true) // '[object Boolean]'\na.call([]) // '[object Array]'\na.call(function(){}) //'[object Function]'\na.call({}) //'[object Object]'\na.call(undefined) //'[object Undefined]'\na.call(null) //'[object Null]'\n\nfunction Fn(){};\nFn.prototype = new Array();\nvar f = new Fn();\na.call(f) // '[object Object]'\n\nvar o1 = { [Symbol.toStringTag]: \"A\" };\nvar o2 = { [Symbol.toStringTag]: null };\n\nObject.prototype.toString.call(o1); // '[object A]'\nObject.prototype.toString.call(o2);      // => \"[object Object]\" //只能是字符串 不是忽略\n```\n# 类型转换\n## 类型转换规则\nstring to number 空字符串转化为0 其它包含非数字的转化为NaN 数字字符串转为数字\nstring to boolean 空字符串为false 其它都为true\n\nnumber to string 就直接变为数字\nnumber to boolean +0 -0 NaN为false 其它为true\n\nboolean to string true为\"true\" false 为\"false\"\nboolean to number true 为1 false为0\n\nnull to string \"null\"\nnull to boolean false\nnull to number 0\n\nundefined to string \"undefined\"\nundefined to boolean false\nundefined to number NaN\n\nSymbol to string 'Symbol()'\nSymbol to boolean true\nSymbol to number false\n\nArray to string []变为\"\" 其它逗号连接起来\nArray to boolean true\nArray to number []为0 先转换为基本类型字符串 再判断有非数字为NaN\n\nObject to String 调用toString方法 \"[object object]\"\nObject to boolean true\nObject to number NaN\n\n## 显式类型转换\n- Number(a) 转换规则见上面\n- parseInt(b) 不会把其他类型转化为数字 从头开始识别数字 能识别到几返回 识别不到就停止，不是数字开头的字符串判断为NaN\n- Boolean() ! !!  null undefined NaN false '' +0 -0为false 其他为ture\n- a.toString() 转换为字符串\n\n## 隐式类型转换\n1. 加号 \n- 一侧为字符串则将另一侧转换为字符串，再拼接起来；0+'1' = '01'\n- 一侧为数字 另一侧为基本类型非字符串 则将另一侧转换为数字再先加 1+ false = 1\n- 一侧为数字 另一侧为非基本类型 则将另一侧转换为字符串 再拼接起来 0+{} = \"0[Object Object]\"\n2. 减号 乘号 除号  将非number转为number\n3. ++a  +b -b 将非number转为number\n4. < > >= <= 转为boolean\n5. == 转为boolean\n- 如果两测是undefined null 则为true 如果两测是NaN 则为false\n- 类型相同直接比较\n- 类型不同先转换为相同类型比较\n- 如果一侧为number 另一侧为string 则把string转为number 再比较\n- 如果一侧为boolean 则先会转换为number再比较\n- 如果一侧为object 则先会转化为原始类型再比较\n> [] == ![] 为true {} == !{}为false 原因\n> [] == ![] ！优先级高 ![]为false  再比较 [] == false 一侧为boolean转户为数字 再比较[] == 0 []为引用类型，先转换为原始类型空字符串，再比较\"\"=0，\"\"转户为数字0 就等于比较 0 == 0 为true\n> 简化 [] == ![] >> [] == false >> [] == 0 >> \"\" == 0 >> 0 == 0 =>true\n> {} == !{} !{}优先级高 !{}为false 再比较{} == false 一侧为boolean转户为数字 再比较{} == 0 {}，先转换为原始类型NaN  就等于比较 NaN  == 0 为false\n> 简化 {} == !{} >> {} == false >> {} == 0 >> NaN == 0 => false\n> 核心是 []转为数字是0 {}转为数字是NaN \n\n# 对象\n## 包装对象 String Object Boolean\n利用方法new String() new Object() new Boolean() 可以将基本类型转化为对象 应用类型，这将装箱\n将包装对象转换为基本类型 叫拆箱 会先调用valueOf 再调用toString()直到转换为原始类型 如果没有就报错typeError\n\n在调用基本类型调用String Object Boolean上的方法或属性时 js引擎会自动将原始值转化为包装对象实例 这样就可以调用包装对象的属性和方法。并且在使用后立即销毁实例。\n## 对象的属性\n### 数据属性\n1. value 值\n2. writable 能否被赋值\n3. enumerable 能否被枚举 for in Object.keys\n4. configurable 能否被删除或者改变属性值\n获取对象属性用getOwnPropertyDescriptor\n设置对象属性用defineProperty\n```js\nvar a ={a:1}\nObject.getOwnPropertyDescriptor(a,'a') //{configurable: true,enumerable: true,value: 1,writable: true}\n\nObject.defineProperty(a,'a',{value:5,configurable: false,enumerable: false,writable: false})\n```\n### 访问器属性\n1. Getter 取值\n2. setter 赋值\n3. enumerable 能否被枚举 for in  Object.keys\n4. configurable 能否被删除或者改变属性值\n```js\nlet o = {\n  b: 1,\n  get a() {\n    return this.b;\n  },\n  set a(i) {\n    this.b = i;\n  },\n};\n\nconsole.log(o.a); // 1\no.a = 5;\nconsole.log(o.a); // 5\n\n\nvar o = { b: 1 };\nObject.defineProperty(o, 'a', {\n  set: function (value) {\n    this.b = value + 100;\n  },\n  get: function () {\n    return this.b;\n  },\n});\n\nconsole.warn(o.a); // 6\no.a = 6;\nconsole.warn(o.a); // 106\n```\n","tags":["数据结构"],"categories":["javascript"]},{"title":"Hello World","url":"/smile/2022/01/03/6/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["tags2","tags1"],"categories":["其他"]},{"title":"Hello World","url":"/smile/2022/01/01/5/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["tags2","tags1"],"categories":["其他"]},{"title":"Hello World","url":"/smile/2021/02/01/3/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["tags2","tags1"],"categories":["后端"]},{"title":"How to use Hexo to make myself blog","url":"/smile/2021/02/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["hexo","blog"],"categories":["其他"]},{"title":"防抖和节流","url":"/smile/2021/02/01/防抖和节流/","content":"防抖和节流不管是在工作实践中还是面试中，都是存在感非常强的知识点，下面我将从防抖节流的理论+实践，具体说明什么是防抖和节流，以及如何在项目实践中用到防抖和节流。\n<!-- more -->\n## 什么是防抖和节流\n防抖和节流都是为了避免操作频繁触发 减少开支 而采用的一种方法，下面就具体说明下两者\n### 防抖 debounce\n防抖就是保证事件触发后n秒后才执行，如果n秒内事件重复被触发，则重新计算时间\n防抖的常用场景：输入搜索框 文本域自动保存 避免重复点击\n实现方法是：利用闭包的原理 用一个变量保存一个定时器 返回一个回调函数，如果这个timer存在就清除timer 然后重新设置定时器，在n秒后执行某个时间 \n#### 自己实现防抖\n参考： https://github.com/mqyqingfeng/Blog/issues/22\n1. 第一步 简单版本\n```tsx\nfunction debounce(func:Function,wait:number) {\n  let timer\n  return function() {\n    if(timer) {\n      clearTimeout(timer)\n    }\n    timer = setTimeout(func,wait)\n  }\n}\n```\n但这里this指向不正确 会指向window 但是我们真正要的是指向返回的函数\n2. 第二步 this 绑定指向返回的函数\n```tsx\nfunction debounce(func:Function,wait:number) {\n  let timer\n  return function() {\n    const context = this;\n    if(timer) {\n      clearTimeout(timer)\n    }\n    timer = setTimeout(function () {\n      func.apply(context)\n    },wait)\n  }\n}\n```\n3. 第三步 传参\n```tsx\nfunction debounce(func:Function,wait:number) {\n  let timer\n  return function() {\n    const context = this;\n    const args = arguments;\n    if(timer) {\n      clearTimeout(timer)\n    }\n    timer = setTimeout(function () {\n      func.apply(context,args)\n    },wait)\n  }\n}\n```\n4. 第四步 有些场景需要 立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行\n```typescript\n/*\n * fun 要执行的函数\n * delay 延迟执行的时间\n * immediate 是否立即执行\n *\n * */\nfunction debounce(func:Function,wait:number,immediate:boolean) {\n  let timer: null | NodeJS.Timeout = null\n  return function () {\n    const context = this;\n    const args = arguments;\n    if(timer) {\n      clearTimeout(timer)\n    } \n    \n    if(immediate) {\n      const callNow = !timer;\n      if(callNow) {\n        func.apply(context,args)\n      }\n      setTimeout(()=>{\n        timer = null;\n      },wait)\n    } else {\n      timer = setTimeout(function () {\n         func.apply(context,args)\n      },wait)\n    }\n   \n  }\n}\n\n```\n5. 第五步 有些场景需要有返回值\n```typescript\n/*\n * fun 要执行的函数\n * delay 延迟执行的时间\n * immediate 是否立即执行\n *\n * */\nfunction debounce(func:Function,delay:number,immediate:boolean) {\n   let timer: null | NodeJS.Timeout = null;\n   let result;\n   const debounced =  function () {\n      const context = this;\n      const args = arguments;\n      if(timer) {\n         clearTimeout(timer)\n      }\n\n      if(immediate) {\n         const callNow = !timer;\n         if(callNow) {\n            result = func.apply(context,args)\n         }\n         setTimeout(()=>{\n            timer = null;\n         },delay)\n      } else {\n         timer = setTimeout(function () {\n            func.apply(context,args)\n         },delay)\n      }\n      return result;\n   };\n   debounced.cancel = function () {\n     clearTimeout(timer);\n     timer = null;\n   }\n   return debounced;\n}\n\n```\n\n\n### 节流 throttle\n节流：每隔一段时间，只执行一次事件\n\n#### 自己实现节流 throttle\n参考： https://github.com/mqyqingfeng/Blog/issues/26\n1. 使用时间戳：当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行\n```tsx\nfunction throttle(func:Function,wait:number) {\n  let previous = 0;\n  return function () {\n    const context=this;\n    const args = arguments\n    const now = +new Date()\n    if(now-previous>wait) {\n      func.apply(context,args)\n      previous = now;\n    }\n  }\n}\n```\n这种方法一开始世界会立刻执行，但是事件停止触发后就不会再执行\n2. 使用定时器:设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\n```tsx\nfunction throttle(func:Function,wait:number) {\n  let timer: null | NodeJS.Timeout = null;\n  return function () {\n    const context=this;\n    const args = arguments\n    if(!timer) {\n      timer = setTimeout(function () {\n        timer = null;\n        func.apply(context,args)\n      },wait)\n    }\n  }\n}\n```\n这种方法一开始世界不会立刻执行，但是事件停止触发后就会再执行一次\n3. 综合上面的 开始和结束都能再执行一次的\n```tsx\nfunction throttle(func, wait) {\n  var timeout, context, args, result;\n  var previous = 0;\n\n  var later = function() {\n    previous = +new Date();\n    timeout = null;\n    func.apply(context, args)\n  };\n\n  var throttled = function() {\n    var now = +new Date();\n    //下次触发 func 剩余的时间\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    // 如果没有剩余的时间了或者你改了系统时间\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout) {\n      timeout = setTimeout(later, remaining);\n    }\n  };\n  return throttled;\n}\n```\n4. 头和尾是否触发\n   leading：false 表示禁用第一次执行\n   trailing: false 表示禁用停止触发的回调\n```tsx\n// 第四版\nfunction throttle(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n        previous = options.leading === false ? 0 : new Date().getTime();\n        timeout = null;\n        func.apply(context, args);\n        if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n        var now = new Date().getTime();\n        if (!previous && options.leading === false) previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n            if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n    };\n\n  throttled.cancel = function() {\n    clearTimeout(timeout);\n    previous = 0;\n    timeout = null;\n  }\n    return throttled;\n}\n```\nleading：false 和 trailing: false 不能同时设置。\n\n\n## 在react项目中使用防抖和节流实践\n\n### 输入框搜索\n下面是在react项目中如何利用防抖\n1. 方法一直接调用debounce函数包裹输入框的onchange方法\n```tsx\n<Input\n  placeholder=\"请输入用户名\"\nonChange={changeName}\n/>\n\nconst [name, setName] = useState('')\n\nconst changeName = debounce(\n  (e: { target: { value: SetStateAction<string> } }) =>\n    setName(e.target.value),\n  500,\n  false\n)\n```\n效果如下\n2. 方法二 react hook\n```tsx\n/*\n * fun 要执行的函数\n * delay 延迟执行的时间\n * immediate 是否立即执行\n *\n * */\nimport { useCallback, useRef } from 'react'\n\nexport function useDebounce(func: any, delay: number, immediate: boolean) {\n  const timer = useRef<null | NodeJS.Timeout>(null)\n  return useCallback(function (this: any, ...args: any) {\n    const context = this\n    if (timer.current) {\n      clearInterval(timer.current)\n    } else if (immediate) {\n      func.call(context, ...args)\n    }\n\n    function timeFinish() {\n      if (!immediate) {\n        func.call(context, ...args)\n      }\n      timer.current = null\n    }\n    timer.current = setTimeout(timeFinish, delay)\n  }, [])\n}\n\n```\n\n### 格式校验\n","tags":["防抖","节流","自定义hook"],"categories":["javascript"]},{"title":"Hello World","url":"/smile/2021/01/02/4/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["tags2","tags1"],"categories":["其他"]},{"title":"Hello World","url":"/smile/2021/01/01/2/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["tags2"],"categories":["javascript"]}]