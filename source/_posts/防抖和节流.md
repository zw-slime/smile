---
title: 防抖和节流
author: zhangwei
description: 什么是防抖和节流以及区别和实现，在react项目实践，如何写一个防抖节流的hook
cover: https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fqqpublic.qpic.cn%2Fqq_public%2F0%2F0-3103668252-AA9D34452424D52531C7C43B51D247B5%2F0%3Ffmt%3Djpg%26size%3D40%26h%3D383%26w%3D900%26ppv%3D1.jpg&refer=http%3A%2F%2Fqqpublic.qpic.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650981361&t=496516f5822fdf85474abc234118202d
date: 2021-2-1
categories: 
  - javascript
tags: 
  - 防抖
  - 节流
  - 自定义hook
---
防抖和节流不管是在工作实践中还是面试中，都是存在感非常强的知识点，下面我将从防抖节流的理论+实践，具体说明什么是防抖和节流，以及如何在项目实践中用到防抖和节流。
<!-- more -->
## 什么是防抖和节流

### 防抖 debounce




### 节流 throttle




### 防抖和节流的区别



## 自己实现防抖节流 

### 防抖

```typescript
/*
 * fun 要执行的函数
 * delay 延迟执行的时间
 * immediate 是否立即执行
 *
 * */
function debounce(func:Function,delay:number,immediate:boolean) {
  let timer: null | NodeJS.Timeout = null
  return function (this:any) {
    const context=this;

    function timerFinish () {
      if(!immediate) {
        func.apply(context,arguments)
      }
      timer = null
    }
    
    if(timer) {
      clearTimeout(timer)
    } else if(immediate) {
      func.apply(context,arguments)
    }
    timer = setTimeout(timerFinish)
  }
}

```

### 节流

## 在react项目中使用防抖和节流实践

### 输入框搜索
下面是在react项目中如何利用防抖
1. 方法一直接调用debounce函数包裹输入框的onchange方法
```tsx
<Input
  placeholder="请输入用户名"
onChange={changeName}
/>

const [name, setName] = useState('')

const changeName = debounce(
  (e: { target: { value: SetStateAction<string> } }) =>
    setName(e.target.value),
  500,
  false
)
```
效果如下
2. 方法二 react hook
```tsx
/*
 * fun 要执行的函数
 * delay 延迟执行的时间
 * immediate 是否立即执行
 *
 * */
import { useCallback, useRef } from 'react'

export function useDebounce(func: any, delay: number, immediate: boolean) {
  const timer = useRef<null | NodeJS.Timeout>(null)
  return useCallback(function (this: any, ...args: any) {
    const context = this
    if (timer.current) {
      clearInterval(timer.current)
    } else if (immediate) {
      func.call(context, ...args)
    }

    function timeFinish() {
      if (!immediate) {
        func.call(context, ...args)
      }
      timer.current = null
    }
    timer.current = setTimeout(timeFinish, delay)
  }, [])
}

```

### 格式校验
